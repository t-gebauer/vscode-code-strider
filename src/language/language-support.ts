import { SyntaxNode } from "web-tree-sitter";
import { defineLanguage, RuleExecutor, LanguageDefinition, NodeAccessorFunction, Rule } from "./language-definition";
import { javaScript } from "./languages/language-javascript";

const languages = new Map<string, LanguageDefinition>();

export function initializeLanguages() {
    // All supported languages must be listed here. A minimal definition simply declares that the language is supported.
    // The language ids have to match VS Codes internal language ids.
    // Additionally, an activation event should be registered in `package.json`.
    // For each language a tree-sitter parser build has to be present in `<project-root>/wasm`, matching the pattern `tree-sitter-<language-id>.wasm`.
    // These are usually generated by the Tree-sitter CLI: `tree-sitter build-wasm`.
    const languageDefinitions: LanguageDefinition[] = [
        javaScript,
        defineLanguage('html'),
        defineLanguage('clojure'),
    ];
    languageDefinitions.forEach(def => {
        languages.set(def.languageId, def);
    });
}

export function isLanguageSupported(languageId: string): boolean {
    return languages.get(languageId) !== undefined;
}

export function getLanguageDefinition(languageId: string): LanguageDefinition {
    const def = languages.get(languageId);
    if (!def) { throw new Error(`Missing language definition: ${languageId}`); }
    return def;
}

export function getOverrideFor(languageDefinition: LanguageDefinition, command: keyof RuleExecutor, node: SyntaxNode): NodeAccessorFunction | undefined {
    const firstMatchingRule = languageDefinition.rules.find(([matcher, executor]) => {
        return executor[command] &&
            (!matcher.selected || (matcher.selected === node.type)) &&
            (!matcher.parent || (matcher.parent === node.parent?.type));
    });
    if (firstMatchingRule) {
        const [_, executor] = firstMatchingRule;
        return executor[command];
    }
    return undefined;
}