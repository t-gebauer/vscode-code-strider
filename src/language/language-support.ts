import { SyntaxNode } from "web-tree-sitter"
import {
    defineLanguage,
    RuleExecutor,
    LanguageDefinition,
    NodeAccessorFunction,
} from "./language-definition"
import { javaScript } from "./languages/language-javascript"
import { python } from "./languages/language-python"

// All supported languages must be listed here. A minimal definition simply declares that the language is supported.
// The language ids have to match VS Codes internal language ids.
// Additionally, an activation event should be registered in `package.json`.
// For each language a tree-sitter parser build has to be present in `<project-root>/wasm`, matching the pattern `tree-sitter-<language-id>.wasm`.
// These are usually generated by the Tree-sitter CLI: `tree-sitter build-wasm`.
const languages: Map<string, LanguageDefinition> = new Map(
    [
        defineLanguage("c"),
        defineLanguage("clojure"),
        defineLanguage("css"),
        defineLanguage("fennel"),
        defineLanguage("html"),
        defineLanguage("java"),
        javaScript,
        // TODO: VSCode maps some json files to "jsonc" - JSON with comments.
        //       The normal "json" grammar should suffice. Even though the
        //       comments would be labeled as ERROR.
        defineLanguage("json"),
        // TODO: ignore / don't select "soft_line_break"s
        defineLanguage("markdown"),
        defineLanguage("nix"),
        python,
        defineLanguage("scss"),
        defineLanguage("typescript"),
    ].map((def: LanguageDefinition) => [def.languageId, def])
)

export namespace Languages {
    export function isSupported(languageId: string): boolean {
        return languages.has(languageId)
    }

    export function getDefinition(languageId: string): LanguageDefinition {
        const def = languages.get(languageId)
        if (!def) {
            throw new Error(`Missing language definition: ${languageId}`)
        }
        return def
    }

    export function getOverrideFor(
        languageDefinition: LanguageDefinition,
        command: keyof RuleExecutor,
        node: SyntaxNode
    ): NodeAccessorFunction | undefined {
        const firstMatchingRule = languageDefinition.rules.find(([matcher, executor]) => {
            return (
                executor[command] &&
                (!matcher.selected || matcher.selected === node.type) &&
                (!matcher.parent || matcher.parent === node.parent?.type)
            )
        })
        if (firstMatchingRule) {
            const [, executor] = firstMatchingRule
            return executor[command]
        }
        return undefined
    }
}
